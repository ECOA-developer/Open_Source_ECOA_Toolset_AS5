/*
 * Copyright 2017, BAE Systems Limited and GE Aviation Limited.
 *  
 * This software and its outputs are not claimed to be fit or safe for any purpose. Any user should
 * satisfy themselves that this software or its outputs are appropriate for its intended purpose.
*/
package com.iawg.ecoa.xmlprocessor;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.ValidationEvent;
import javax.xml.bind.ValidationEventLocator;
import javax.xml.bind.util.ValidationEventCollector;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.xml.sax.SAXException;

/**
 * This is the base class for the processing of an XML file using JAXB.
 * 
 * @author Shaun Cullimore
 */
public class XMLFileProcessor {
	private static final Logger LOGGER = LogManager.getLogger(XMLFileProcessor.class);
	private static final String SEP_PATTERN_01 = "- msg is: \"";
	static final String JAXP_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
	static final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema";
	static final String JAXP_SCHEMA_SOURCE = "http://java.sun.com/xml/jaxp/properties/schemaSource";
	private String rootOfClassHierarchy;
	private String schemaFile;
	private Object unmarshalledObject;

	public XMLFileProcessor(String schemaFile, String root) {
		rootOfClassHierarchy = root;
		this.schemaFile = schemaFile;
	}

	// Public instance methods
	public Object parseFile(Path file) {
		JAXBContext jbc = null;

		try {
			jbc = JAXBContext.newInstance(rootOfClassHierarchy);
		} catch (JAXBException e) {
			e.printStackTrace();
			
		}

		Unmarshaller u = null;
		try {
			u = jbc.createUnmarshaller();

			SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
			try {
				// TODO - massive hack to not set schema validation if
				// udpbinding - Mark Keely requires more than 16 platforms
				// so without altering the schema, this is the best option for
				// now!
				if (!schemaFile.equals("ecoa-udpbinding-1.0.xsd")) {
					factory.setResourceResolver(new ECOAEntityResolver());
					InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(schemaFile);
					if (is == null) {
						is = this.getClass().getClassLoader().getResourceAsStream(schemaFile);
					}
					Schema schema = factory.newSchema(new StreamSource(is));
					u.setSchema(schema);
				}
			} catch (SAXException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (JAXBException e) {
			e.printStackTrace();
			
		}

		ValidationEventCollector vec = new ValidationEventCollector();

		try {
			u.setEventHandler(vec);
		} catch (JAXBException e) {
			e.printStackTrace();
			
		}

		unmarshalledObject = null;

		try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
			try {
				unmarshalledObject = u.unmarshal(reader);
			} catch (UnmarshalException e) {
				// This can occur if the xml file and schema do not match the
				// class files
				// generated by xjc
				LOGGER.info("ERROR - unmarshalling error msg: \"" + e.toString() + "\"");
				
			} catch (JAXBException e) {
				e.printStackTrace();
				
			}

		} catch (IOException x) {
			LOGGER.info("ERROR - file \"" + file + "\" not found");
			
		}

		// Check for validation events and prepare to return "true" for good or
		// "false" for failed validation
		ValidationEvent[] va = vec.getEvents();

		if (va.length > 0) {
			// There are errors/warnings
			for (int i = 0; i < va.length; i++) {
				int ev = va[i].getSeverity();

				switch (ev) {
				case ValidationEvent.ERROR:
					LOGGER.info("Validation event of severity ERROR generated");
					LOGGER.info(SEP_PATTERN_01 + va[i].getMessage() + "\"");
					break;

				case ValidationEvent.FATAL_ERROR:
					LOGGER.info("Validation event of severity FATAL_ERROR generated");
					LOGGER.info(SEP_PATTERN_01 + va[i].getMessage() + "\"");
					break;

				case ValidationEvent.WARNING:
					LOGGER.info("Validation event of severity WARNING generated");
					LOGGER.info(SEP_PATTERN_01 + va[i].getMessage() + "\"");
					break;

				default:
					LOGGER.info("ERROR - unrecognised validation event received");
					break;
				}

				ValidationEventLocator vel = va[i].getLocator();
				LOGGER.info("- event occured at line " + vel.getLineNumber() + " column " + vel.getColumnNumber());
			}

			// TBD Could allow the user the flexibility to stop on a warning, an
			// error or
			// or a fatal error, or just plough on regardless (the default)
			
		} else {
			LOGGER.info("There have been no validation errors...");
		}

		// LOGGER.info("Unmarshalled object is " + unmarshalledObject);

		return unmarshalledObject;
	}

}
